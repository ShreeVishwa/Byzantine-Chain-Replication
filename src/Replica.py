# -*- generated by 1.0.9 -*-
import da
PatternExpr_344 = da.pat.TuplePattern([da.pat.ConstantPattern('re-trans-client'), da.pat.FreePattern('encrypt_oper'), da.pat.FreePattern('encrypt_rid')])
PatternExpr_353 = da.pat.FreePattern('client')
PatternExpr_979 = da.pat.TuplePattern([da.pat.ConstantPattern('forward-req'), da.pat.FreePattern('encrypt_oper'), da.pat.FreePattern('encrypt_rid'), da.pat.FreePattern('client')])
PatternExpr_990 = da.pat.FreePattern('replica')
PatternExpr_1519 = da.pat.TuplePattern([da.pat.ConstantPattern('head-retrans-head'), da.pat.FreePattern('encrypt_oper'), da.pat.FreePattern('encrypt_rid'), da.pat.FreePattern('client')])
PatternExpr_1530 = da.pat.FreePattern('head')
PatternExpr_1890 = da.pat.TuplePattern([da.pat.ConstantPattern('initial_transmission'), da.pat.FreePattern('encrypt_operation'), da.pat.FreePattern('encrypt_rid')])
PatternExpr_1899 = da.pat.FreePattern('client')
PatternExpr_2602 = da.pat.TuplePattern([da.pat.ConstantPattern('result-shuttle'), da.pat.FreePattern('encrypt_hashresult'), da.pat.FreePattern('client')])
PatternExpr_2611 = da.pat.FreePattern('frep')
PatternExpr_3009 = da.pat.TuplePattern([da.pat.ConstantPattern('rep_trans'), da.pat.FreePattern('encrypt_slot'), da.pat.FreePattern('encrypt_operation'), da.pat.FreePattern('encrypt_order_proof'), da.pat.FreePattern('encrypt_hashresult'), da.pat.FreePattern('client'), da.pat.FreePattern('rid_slot'), da.pat.FreePattern('rid')])
PatternExpr_3027 = da.pat.FreePattern('prev_rep')
_config_object = {}
import sys
import nacl.encoding
import nacl.hash
import nacl.signing
from nacl.bindings.utils import sodium_memcmp
from re import split
import time
import logging

class replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_0', PatternExpr_344, sources=[PatternExpr_353], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_343]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_1', PatternExpr_979, sources=[PatternExpr_990], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_978]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_2', PatternExpr_1519, sources=[PatternExpr_1530], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_1518]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_3', PatternExpr_1890, sources=[PatternExpr_1899], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_1889]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_4', PatternExpr_2602, sources=[PatternExpr_2611], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_2601]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_5', PatternExpr_3009, sources=[PatternExpr_3027], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_3008])])

    def setup(self, a, d, r, c, public_key_dict, pk, replica_timeout, head_timeout, failure, **rest_3944):
        super().setup(a=a, d=d, r=r, c=c, public_key_dict=public_key_dict, pk=pk, replica_timeout=replica_timeout, head_timeout=head_timeout, failure=failure, **rest_3944)
        self._state.a = a
        self._state.d = d
        self._state.r = r
        self._state.c = c
        self._state.public_key_dict = public_key_dict
        self._state.pk = pk
        self._state.replica_timeout = replica_timeout
        self._state.head_timeout = head_timeout
        self._state.failure = failure
        self._state.s = 0
        self._state.terminate = self._state.a
        self._state.d = self._state.d
        self._state.res = ''
        self._state.result = dict()
        self._state.pk = self._state.pk
        self._state.public_key_dict = self._state.public_key_dict
        self._state.hr = dict()
        self._state.slot = (- 1)
        self._state.history = dict()
        self._state.hashresult = []
        self._state.rid_slot = dict()
        self._state.idr = None
        self._state.fail = []
        self._state.ncr = dict()
        self._state.nfr = dict()
        self._state.ns = dict()
        self._state.nrs = dict()
        self._state.cr = 0
        self._state.co = 0
        self._state.drs = 0
        self._state.drop = 0

    def run(self):
        logging.basicConfig(format='%(asctime)s : %(message)s', level=logging.INFO, filename=(sys.argv[(- 1)][0:(- 4)] + '_log.log'))
        super()._label('_st_label_3942', block=False)
        _st_label_3942 = 0
        while (_st_label_3942 == 0):
            _st_label_3942 += 1
            if False:
                _st_label_3942 += 1
            else:
                super()._label('_st_label_3942', block=True)
                _st_label_3942 -= 1

    def _replica_handler_343(self, encrypt_oper, encrypt_rid, client):
        client_rep_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[client], encoder=nacl.encoding.HexEncoder)
        try:
            client_rep_dkey.verify(encrypt_oper)
            client_rep_dkey.verify(encrypt_rid)
            operation = encrypt_oper.message.decode()
            rid = int(encrypt_rid.message.decode())
        except nacl.exceptions.BadSignatureError:
            logging.error(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : Client ') + str(self._state.c.index(client))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' re-transmission signature failed for rid ') + str(rid)))
        logging.info(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : Client ') + str(self._state.c.index(client))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' re-transmission signature success for rid ') + str(rid)))
        logging.info(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : Client ') + str(self._state.c.index(client))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' re-transmission msg received for rid ') + str(rid)))
        try:
            self._state.ncr[self._state.c.index(client)] = (self._state.ncr[self._state.c.index(client)] + 1)
        except KeyError:
            self._state.ncr[self._state.c.index(client)] = 0
        if (self._state.r.index(self._state.idr) == 5):
            logging.info(((('ncr is ' + str(self._state.ncr)) + ' fail is ') + str(self._state.fail)))
        for x in self._state.fail:
            if (x[0].strip() == 'client_request'):
                if (int(x[1]) in self._state.ncr.keys()):
                    if ((self._state.ncr[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                        logging.info(((((((('replica ' + str(self._state.r.index(self._state.idr))) + ' Client_request failure triggered at replica ') + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                        if (x[3].strip() == 'change_operation'):
                            self._state.co = 1
                        if (x[3].strip() == 'change_result'):
                            self._state.cr = 1
                        if (x[3].strip() == 'drop_result_stmt'):
                            self._state.drs = 1
                        if (x[3].strip() == 'drop'):
                            self._state.drop = 1
        if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.history.keys())):
            if (self._state.rid_slot[(rid, client)] in self._state.hr.keys()):
                self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]], rid), to=client)
                logging.info(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(self._state.idr))) + ' -> Client ') + str(self._state.c.index(client))) + ' cached result sent to client for rid ') + str(rid)))
        else:
            logging.info((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : else condition enter'))
            if (not (self._state.r.index(self._state.idr) == 0)):
                encrypt_oper = self._state.pk.sign(operation.encode())
                encrypt_rid = self._state.pk.sign(str(rid).encode())
                logging.info((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : before sending to head'))
                self.send(('forward-req', encrypt_oper, encrypt_rid, client), to=self._state.r[0])
                logging.info(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(self._state.idr))) + ' ->Replica 0 forward request sent for client ') + str(self._state.c.index(client))) + ' rid ') + str(rid)))
                super()._label('_st_label_866', block=False)
                _st_label_866 = 0
                self._timer_start()
                while (_st_label_866 == 0):
                    _st_label_866 += 1
                    if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.hr.keys())):
                        self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]]), to=client)
                        logging.info(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(self._state.idr))) + ' -> Client ') + str(self._state.c.index(client))) + ' cached result arrived before timeout and sent to client for rid ') + str(rid)))
                        _st_label_866 += 1
                    elif self._timer_expired:
                        logging.info(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(self._state.idr))) + ' -> Olympus proof of misbehaviour : cached result time out for client ') + str(self._state.c.index(client))) + ' rid ') + str(rid)))
                        _st_label_866 += 1
                    else:
                        super()._label('_st_label_866', block=True, timeout=self._state.replica_timeout)
                        _st_label_866 -= 1
    _replica_handler_343._labels = None
    _replica_handler_343._notlabels = None

    def _replica_handler_978(self, encrypt_oper, encrypt_rid, client, replica):
        rep_head_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[replica], encoder=nacl.encoding.HexEncoder)
        try:
            rep_head_dkey.verify(encrypt_oper)
            rep_head_dkey.verify(encrypt_rid)
            operation = encrypt_oper.message.decode()
            rid = int(encrypt_rid.message.decode())
        except nacl.exceptions.BadSignatureError:
            logging.error(((('Replica 0 : Replica ' + str(self._state.r.index(replica))) + ' -> Replica 0 forward-req signature failed for rid ') + str(rid)))
        logging.info(((('Replica 0 : Replica ' + str(self._state.r.index(replica))) + ' -> Replica 0 forward-req signature success for rid ') + str(rid)))
        logging.info(((((('Replica 0 received forwarded request from ' + str(self._state.r.index(replica))) + ' by client ') + str(self._state.c.index(client))) + ' rid ') + str(rid)))
        try:
            self._state.nfr[self._state.c.index(client)] = (self._state.nfr[self._state.c.index(client)] + 1)
        except KeyError:
            self._state.nfr[self._state.c.index(client)] = 0
        for x in self._state.fail:
            if (x[0].strip() == 'forwarded_request'):
                if (int(x[1]) in self._state.nfr.keys()):
                    if ((self._state.nfr[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                        logging.info(((((('Replica 0: Forward_request failure triggered at replica ' + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                        if (x[3].strip() == 'change_operation'):
                            self._state.co = 1
                        if (x[3].strip() == 'change_result'):
                            self._state.cr = 1
                        if (x[3].strip() == 'drop_result_stmt'):
                            self._state.drs = 1
                        if (x[3].strip() == 'drop'):
                            self._state.drop = 1
        if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.hr.keys())):
            self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]], rid), to=client)
            logging.info(((('Replica 0: Replica 0 has the result shuttle cached and sent to Client ' + str(self._state.c.index(client))) + '  rid ') + str(rid)))
        elif (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.history.keys())):
            logging.info('Replica 0: Replica 0 has started timer')
            super()._label('_st_label_1322', block=False)
            _st_label_1322 = 0
            self._timer_start()
            while (_st_label_1322 == 0):
                _st_label_1322 += 1
                if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.hr.keys())):
                    self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]]), to=client)
                    logging.info(((('Replica 0: Replica 0 has the result shuttle cached before timer expired and sent to Client ' + str(self._state.c.index(client))) + '  rid ') + str(rid)))
                    _st_label_1322 += 1
                elif self._timer_expired:
                    logging.info('Replica 0: Replica 0 timer expired, reconfig request to olympus')
                    _st_label_1322 += 1
                else:
                    super()._label('_st_label_1322', block=True, timeout=self._state.head_timeout)
                    _st_label_1322 -= 1
        else:
            logging.info(((("Replica 0: Replica 0 doesn't have the slot for Client " + str(self._state.c.index(client))) + '  rid ') + str(rid)))
            encrypt_oper = self._state.pk.sign(operation.encode())
            encrypt_rid = self._state.pk.sign(str(rid).encode())
            self.send(('head-retrans-head', encrypt_oper, encrypt_rid, client), to=self._state.r[0])
            logging.info((((('Replica 0: Replica 0 has sent request for Client ' + str(self._state.c.index(client))) + '  rid ') + str(rid)) + ' to Replica0 '))
            logging.info('Replica 0: Replica 0 has started the timer')
            super()._label('_st_label_1455', block=False)
            _st_label_1455 = 0
            self._timer_start()
            while (_st_label_1455 == 0):
                _st_label_1455 += 1
                if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.hr.keys())):
                    logging.info(((('Replica 0: Replica 0 has the result shuttle cached and sent to Client ' + str(self._state.c.index(client))) + '  rid ') + str(rid)))
                    self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]]), to=client)
                    _st_label_1455 += 1
                elif self._timer_expired:
                    logging.info('Replica 0: Replica 0 timer expired, reconfig request to olympus')
                    _st_label_1455 += 1
                else:
                    super()._label('_st_label_1455', block=True, timeout=self._state.head_timeout)
                    _st_label_1455 -= 1
    _replica_handler_978._labels = None
    _replica_handler_978._notlabels = None

    def _replica_handler_1518(self, encrypt_oper, encrypt_rid, client, head):
        rep_head_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[replica], encoder=nacl.encoding.HexEncoder)
        try:
            rep_head_dkey.verify(encrypt_oper)
            rep_head_dkey.verify(encrypt_rid)
            operation = encrypt_oper.message.decode()
            rid = int(encrypt_rid.message.decode())
        except nacl.exceptions.BadSignatureError:
            logging.error(('Replica 0 : Replica 0 -> Replica 0 forward-req decryption failed for rid ' + str(rid)))
        self._state.slot = (self._state.slot + 1)
        if (self._state.slot in self._state.history.keys()):
            logging.error(((((('replica 0:  client ' + str(self._state.c.index(client))) + ' -> replica 0 slot error for rid ') + str(rid)) + 'slot ') + str(self._state.slot)))
        self._state.rid_slot[(rid, client)] = self._state.slot
        orderproof.append([self._state.slot, operation])
        self._state.history[self._state.slot] = operation
        x = split("[,()']+", operation)
        if (x[0] == 'put'):
            self._state.d[x[1]] = x[2]
            self._state.res = 'ok'
        if (x[0] == 'get'):
            try:
                self._state.res = self._state.d[x[1]]
            except KeyError:
                self._state.res = ''
        if (x[0] == 'append'):
            try:
                self._state.d[x[1]] = (self._state.d[x[1]] + x[2])
                self._state.res = 'update ok'
            except KeyError:
                self._state.res = 'update failed'
        if (x[0] == 'slice'):
            x[2] = x[2].split(':')
            try:
                self._state.d[x[1]] = self._state.d[x[1]][int(x[2][0]):int(x[2][1])]
                self._state.res = 'slice ok'
            except KeyError:
                self._state.res = 'slice fail'
        self._state.result[self._state.slot] = self._state.res
        i = self._state.r.index(self._state.idr)
        en_res = self._state.res.encode()
        res_digest = nacl.hash.sha256(en_res, encoder=nacl.encoding.HexEncoder)
        res_hash = nacl.encoding.HexEncoder.encode(en_res)
        self._state.hashresult = [[res_digest, res_hash, self._state.slot]]
        encrypt_operation = self._state.pk.sign(operation.encode())
        encrypt_slot = self._state.pk.sign(str(self._state.slot).encode())
        encrypt_hashresult = self._state.pk.sign(repr(self._state.hashresult).encode())
        encrypt_order_proof = self._state.pk.sign(repr(orderproof).encode())
        logging.info(((('replica 0:  replica 0 -> replica ' + str((i + 1))) + ' for slot ') + str(self._state.slot)))
        self.send(('rep_trans', encrypt_slot, encrypt_operation, encrypt_order_proof, encrypt_hashresult, client, self._state.rid_slot, rid), to=self._state.r[(i + 1)])
    _replica_handler_1518._labels = None
    _replica_handler_1518._notlabels = None

    def _replica_handler_1889(self, encrypt_operation, encrypt_rid, client):
        head_client_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[client], encoder=nacl.encoding.HexEncoder)
        try:
            head_client_dkey.verify(encrypt_operation)
            head_client_dkey.verify(encrypt_rid)
            operation = encrypt_operation.message.decode()
            rid = int(encrypt_rid.message.decode())
        except nacl.exceptions.BadSignatureError:
            logging.error(((('replica 0:  client ' + str(self._state.c.index(client))) + ' -head signature fail for rid ') + str(rid)))
        logging.info(((('replica 0:  client ' + str(self._state.c.index(client))) + ' -head signature success for rid ') + str(rid)))
        self._state.idr = self._state.r[0]
        self._state.s = (self._state.s + 1)
        self._state.slot = (self._state.slot + 1)
        if ((str(self._state.r.index(self._state.idr)) in self._state.failure.keys()) and (len(self._state.fail) == 0)):
            for x in self._state.failure[str(self._state.r.index(self._state.idr))]:
                self._state.fail.append(split('[(,)]+', x))
        try:
            self._state.ncr[self._state.c.index(client)] = (self._state.ncr[self._state.c.index(client)] + 1)
        except KeyError:
            self._state.ncr[self._state.c.index(client)] = 0
        orderproof = []
        if (self._state.slot in self._state.history.keys()):
            logging.error(((((('replica 0:  client ' + str(self._state.c.index(client))) + ' -> replica 0 slot error for rid ') + str(rid)) + 'slot ') + str(self._state.slot)))
        self._state.rid_slot[(rid, client)] = self._state.slot
        orderproof.append([self._state.slot, operation])
        self._state.history[self._state.slot] = operation
        x = split("[,()']+", operation)
        if (x[0] == 'put'):
            self._state.d[x[1]] = x[2]
            self._state.res = 'ok'
        if (x[0] == 'get'):
            try:
                self._state.res = self._state.d[x[1]]
            except KeyError:
                self._state.res = ''
        if (x[0] == 'append'):
            try:
                self._state.d[x[1]] = (self._state.d[x[1]] + x[2])
                self._state.res = 'update ok'
            except KeyError:
                self._state.res = 'update failed'
        if (x[0] == 'slice'):
            x[2] = x[2].split(':')
            try:
                self._state.d[x[1]] = self._state.d[x[1]][int(x[2][0]):int(x[2][1])]
                self._state.res = 'slice ok'
            except KeyError:
                self._state.res = 'slice fail'
        for x in self._state.fail:
            if (x[0].strip() == 'client_request'):
                if (int(x[1]) in self._state.ncr.keys()):
                    if ((self._state.ncr[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                        logging.info(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' Client_request failure triggered at replica ') + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                        if (x[3].strip() == 'change_operation'):
                            self._state.co = 1
                        if (x[3].strip() == 'change_result'):
                            self._state.cr = 1
                        if (x[3].strip() == 'drop_result_stmt'):
                            self._state.drs = 1
                        if (x[3].strip() == 'drop'):
                            self._state.drop = 1
        if (self._state.co == 1):
            operation = "get('x')"
            logging.info(((('Replica ' + str(self._state.r.index(self._state.idr))) + " Operation changed to get('x') at replica ") + str(self._state.r.index(self._state.idr))))
            self._state.co = 0
        if (self._state.cr == 1):
            self._state.res = 'OK'
            logging.info(((('Replica ' + str(self._state.r.index(self._state.idr))) + " Result changed to 'OK' at replica ") + str(self._state.r.index(self._state.idr))))
            self._state.cr = 0
        self._state.result[self._state.slot] = self._state.res
        i = self._state.r.index(self._state.idr)
        en_res = self._state.res.encode()
        res_digest = nacl.hash.sha256(en_res, encoder=nacl.encoding.HexEncoder)
        res_hash = nacl.encoding.HexEncoder.encode(en_res)
        self._state.hashresult = [[res_digest, res_hash, self._state.slot]]
        if (self._state.drs == 1):
            del self._state.hashresult[0]
            logging.info(((('Replica ' + str(self._state.r.index(self._state.idr))) + ' :Hashresult of head is omitted at replica ') + str(self._state.r.index(self._state.idr))))
            self._state.drs = 0
        encrypt_operation = self._state.pk.sign(operation.encode())
        encrypt_slot = self._state.pk.sign(str(self._state.slot).encode())
        encrypt_hashresult = self._state.pk.sign(repr(self._state.hashresult).encode())
        encrypt_order_proof = self._state.pk.sign(repr(orderproof).encode())
        if (self._state.drop == 0):
            logging.info(((('replica 0:  replica 0 -> replica ' + str((i + 1))) + ' for slot ') + str(self._state.slot)))
            self.send(('rep_trans', encrypt_slot, encrypt_operation, encrypt_order_proof, encrypt_hashresult, client, self._state.rid_slot, rid), to=self._state.r[(i + 1)])
        else:
            self._state.drop = 0
            logging.info(((('shuttle dropped by head for client ' + str(self._state.c.index(client))) + ' rid ') + str(rid)))
    _replica_handler_1889._labels = None
    _replica_handler_1889._notlabels = None

    def _replica_handler_2601(self, encrypt_hashresult, client, frep):
        try:
            self._state.nrs[self._state.c.index(client)] = (self._state.nrs[self._state.c.index(client)] + 1)
        except KeyError:
            self._state.nrs[self._state.c.index(client)] = 0
        for x in self._state.fail:
            if (x[0].strip() == 'result_shuttle'):
                if (int(x[1]) in self._state.nrs.keys()):
                    if ((self._state.nrs[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                        logging.info(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' Result_shuttle failure triggered at replica ') + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                        if (x[3].strip() == 'change_operation'):
                            self._state.co = 1
                        if (x[3].strip() == 'change_result'):
                            self._state.cr = 1
                        if (x[3].strip() == 'drop_result_stmt'):
                            self._state.drs = 1
                        if (x[3].strip() == 'drop'):
                            self._state.drop = 1
        self._state.s = (self._state.s + 1)
        fr_r_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[frep], encoder=nacl.encoding.HexEncoder)
        try:
            fr_r_dkey.verify(encrypt_hashresult)
            temp_hr = eval(encrypt_hashresult.message.decode())
        except nacl.exceptions.BadSignatureError:
            logging.info((((((('replica ' + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(frep))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' signature fail'))
        logging.info((((((('replica ' + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(frep))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' signature success'))
        for h in temp_hr:
            bres = nacl.encoding.HexEncoder.decode(h[1])
            orig_dgs = nacl.hash.sha256(bres, encoder=nacl.encoding.HexEncoder)
            if sodium_memcmp(h[0], orig_dgs):
                if (not (bres.decode() == self._state.result[h[2]])):
                    logging.info((('Replica ' + str(self._state.r.index(self._state.idr))) + ' Proof of misbehaviour : Reshult_shuttle check failed'))
        self._state.hr[h[2]] = temp_hr
        logging.info(((('Replica ' + str(self._state.r.index(self._state.idr))) + ' Reshult_shuttle cached for slot ') + str(h[2])))
        j = self._state.r.index(frep)
        if ((j - 2) >= 0):
            encrypt_hashresult = self._state.pk.sign(repr(temp_hr).encode())
            self.send(('result-shuttle', encrypt_hashresult, client), to=self._state.r[(j - 2)])
        if ((j - 2) < 0):
            logging.info((('Replica ' + str(self._state.r.index(self._state.idr))) + ' Reshult_shuttle reached head'))
    _replica_handler_2601._labels = None
    _replica_handler_2601._notlabels = None

    def _replica_handler_3008(self, encrypt_slot, encrypt_operation, encrypt_order_proof, encrypt_hashresult, client, rid_slot, rid, prev_rep):
        self._state.s = (self._state.s + 1)
        i = self._state.r.index(prev_rep)
        self._state.idr = self._state.r[(i + 1)]
        if ((str(self._state.r.index(self._state.idr)) in self._state.failure.keys()) and (len(self._state.fail) == 0)):
            for x in self._state.failure[str(self._state.r.index(self._state.idr))]:
                self._state.fail.append(split('[(,)]+', x))
        try:
            self._state.ns[self._state.c.index(client)] = (self._state.ns[self._state.c.index(client)] + 1)
        except KeyError:
            self._state.ns[self._state.c.index(client)] = 0
        for x in self._state.fail:
            if (x[0].strip() == 'shuttle'):
                if (int(x[1]) in self._state.ns.keys()):
                    if ((self._state.ns[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                        logging.info(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' Shuttle failure triggered at replica ') + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                        if (x[3].strip() == 'change_operation'):
                            self._state.co = 1
                        if (x[3].strip() == 'change_result'):
                            self._state.cr = 1
                        if (x[3].strip() == 'drop_result_stmt'):
                            self._state.drs = 1
                        if (x[3].strip() == 'drop'):
                            self._state.drop = 1
        pr_r_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[prev_rep], encoder=nacl.encoding.HexEncoder)
        try:
            pr_r_dkey.verify(encrypt_operation)
            pr_r_dkey.verify(encrypt_hashresult)
            pr_r_dkey.verify(encrypt_order_proof)
            pr_r_dkey.verify(encrypt_slot)
        except nacl.exceptions.BadSignatureError:
            logging.error((((((('replica ' + str((i + 1))) + ': replica ') + str(i)) + ' -> replica ') + str((i + 1))) + 'signature fail '))
        logging.info((((((('replica ' + str((i + 1))) + ': replica ') + str(i)) + ' -> replica ') + str((i + 1))) + 'signature success '))
        self._state.slot = int(encrypt_slot.message.decode())
        operation = encrypt_operation.message.decode()
        logging.info(((((((('replica ' + str((i + 1))) + ': shuttle from replica ') + str(i)) + ' -> replica ') + str((i + 1))) + ' is received for slot ') + str(self._state.slot)))
        self._state.hashresult = eval(encrypt_hashresult.message.decode())
        orderproof = eval(encrypt_order_proof.message.decode())
        if (self._state.slot in self._state.history.keys()):
            logging.error(((((((('replica ' + str((i + 1))) + ':  client ') + str(self._state.c.index(client))) + ' -> replica ') + str((i + 1))) + ' slot error ') + str(self._state.slot)))
        orderproof.append([self._state.slot, operation])
        self._state.history[self._state.slot] = operation
        self._state.rid_slot = rid_slot
        x = split("[,()']+", operation)
        if (x[0] == 'put'):
            self._state.d[x[1]] = x[2]
            self._state.res = 'ok'
        if (x[0] == 'get'):
            try:
                self._state.res = self._state.d[x[1]]
            except KeyError:
                self._state.res = ''
        if (x[0] == 'append'):
            try:
                self._state.d[x[1]] = (self._state.d[x[1]] + x[2])
                self._state.res = 'update ok'
            except KeyError:
                self._state.res = 'update failed'
        if (x[0] == 'slice'):
            x[2] = x[2].split(':')
            try:
                self._state.d[x[1]] = self._state.d[x[1]][int(x[2][0]):int(x[2][1])]
                self._state.res = 'slice ok'
            except KeyError:
                self._state.res = 'slice fail'
        if (self._state.co == 1):
            operation = "get('x')"
            logging.info(((('Replica ' + str(self._state.r.index(self._state.idr))) + " Operation changed to get('x') at replica ") + str(self._state.r.index(self._state.idr))))
            self._state.co = 0
        if (self._state.cr == 1):
            self._state.res = 'OK'
            logging.info(((('Replica ' + str(self._state.r.index(self._state.idr))) + " Result changed to 'OK' at replica ") + str(self._state.r.index(self._state.idr))))
            self._state.cr = 0
        self._state.result[self._state.slot] = self._state.res
        en_res = self._state.res.encode()
        res_digest = nacl.hash.sha256(en_res, encoder=nacl.encoding.HexEncoder)
        res_hash = nacl.encoding.HexEncoder.encode(en_res)
        if (self._state.drs == 1):
            del self._state.hashresult[0]
            logging.info(((('Replica ' + str(self._state.r.index(self._state.idr))) + ' :Result shuttle of head is omitted  at replica ') + str(self._state.r.index(self._state.idr))))
            self._state.drs = 0
        self._state.hashresult.append([res_digest, res_hash, self._state.slot])
        if ((i + 2) < len(self._state.r)):
            encrypt_operation = self._state.pk.sign(operation.encode())
            encrypt_slot = self._state.pk.sign(str(self._state.slot).encode())
            encrypt_hashresult = self._state.pk.sign(repr(self._state.hashresult).encode())
            encrypt_order_proof = self._state.pk.sign(repr(orderproof).encode())
            if (self._state.drop == 0):
                self.send(('rep_trans', encrypt_slot, encrypt_operation, encrypt_order_proof, encrypt_hashresult, client, rid_slot, rid), to=self._state.r[(i + 2)])
                logging.info(((((((('replica ' + str((i + 1))) + ': shuttle from replica ') + str((i + 1))) + ' -> replica ') + str((i + 2))) + ' is sent for slot ') + str(self._state.slot)))
            else:
                self._state.drop = 0
        else:
            self._state.hr[self._state.hashresult[0][2]] = self._state.hashresult
            encrypt_res = self._state.pk.sign(en_res)
            encrypt_hashresult = self._state.pk.sign(repr(self._state.hashresult).encode())
            encrypt_hashresult_shuttle = self._state.pk.sign(repr(self._state.hashresult).encode())
            self.send(('result-shuttle', encrypt_hashresult_shuttle, client), to=prev_rep)
            logging.info(((((('replica ' + str((i + 1))) + ': result shuttle  from tail  -> replica ') + str((self._state.r.index(self._state.idr) - 1))) + ' is sent for slot ') + str(self._state.slot)))
            if (self._state.drop == 0):
                self.send(('result', encrypt_hashresult, encrypt_res, rid), to=client)
                logging.info(((((('replica ' + str((i + 1))) + ': result from tail  -> client ') + str(self._state.c.index(client))) + ' is sent for slot ') + str(self._state.slot)))
            else:
                self._state.drop = 0
    _replica_handler_3008._labels = None
    _replica_handler_3008._notlabels = None
