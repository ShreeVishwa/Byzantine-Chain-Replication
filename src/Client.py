# -*- generated by 1.0.9 -*-
import da
PatternExpr_649 = da.pat.TuplePattern([da.pat.ConstantPattern('re-trans-replica'), da.pat.FreePattern('encrypt_hashresult'), da.pat.FreePattern('encrypt_res'), da.pat.FreePattern('rid')])
PatternExpr_659 = da.pat.FreePattern('replicas')
PatternExpr_770 = da.pat.TuplePattern([da.pat.ConstantPattern('result'), da.pat.FreePattern('encrypt_hashresult'), da.pat.FreePattern('encrypt_res'), da.pat.FreePattern('rid')])
PatternExpr_780 = da.pat.FreePattern('tail')
_config_object = {}
import sys
import nacl.encoding
import nacl.hash
import nacl.signing
from nacl.bindings.utils import sodium_memcmp
from re import split
import time
import logging

class CL(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_CLReceivedEvent_0', PatternExpr_649, sources=[PatternExpr_659], destinations=None, timestamps=None, record_history=None, handlers=[self._CL_handler_648]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CLReceivedEvent_1', PatternExpr_770, sources=[PatternExpr_780], destinations=None, timestamps=None, record_history=None, handlers=[self._CL_handler_769])])

    def setup(self, workload, r, c, cid, public_key_dict, pk, client_timeout, parent, **rest_981):
        super().setup(workload=workload, r=r, c=c, cid=cid, public_key_dict=public_key_dict, pk=pk, client_timeout=client_timeout, parent=parent, **rest_981)
        self._state.workload = workload
        self._state.r = r
        self._state.c = c
        self._state.cid = cid
        self._state.public_key_dict = public_key_dict
        self._state.pk = pk
        self._state.client_timeout = client_timeout
        self._state.parent = parent
        self._state.x = split('[;]+', self._state.workload)
        self._state.rep = self._state.r
        self._state.rec = 0
        self._state.pk = self._state.pk
        self._state.rid = (- 1)
        self._state.result = []
        self._state.timer_expired = False
        self._state.rid_seen = []
        self._state.min_match = (((len(self._state.r) - 1) / 2) + 1)
        self._state.prw = ["put('k1','kv1')", "append('k1',' kv2')", "slice('k1','0:2')", "get('k1')", "put('k2','v1')", "append('k2',' v2')", "slice('k2','0:1')", "get('k2')"]

    def run(self):
        logging.basicConfig(format='%(asctime)s : %(message)s', level=logging.INFO, filename=(sys.argv[(- 1)][0:(- 4)] + '_log.log'))
        if self._state.workload.startswith('pseudorandom'):
            self._state.x = []
            temp = split('[,()]+', self._state.workload)
            pr = [temp[1], temp[2]]
            for i in range(int(pr[1])):
                self._state.x.append(self._state.prw[((int(pr[0]) + i) % len(self._state.prw))])
            logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ' psuedorandom workload is generated'))
        for (i, y) in enumerate(self._state.x):
            self._state.x[i] = self._state.x[i].strip()
            self._state.rid = (self._state.rid + 1)
            self._state.rid_seen.append(0)
            encrypt_oper = self._state.pk.sign(self._state.x[i].encode())
            encrypt_rid = self._state.pk.sign(str(self._state.rid).encode())
            time.sleep((self._state.c.index(self._state.cid) * 0.01))
            logging.info((((((((('Client ' + str(self._state.c.index(self._state.cid))) + ': Client ') + str(self._state.c.index(self._state.cid))) + ' sent request number ') + str(self._state.rid)) + ' opration ') + self._state.x[i]) + ' to replica 0'))
            self.send(('parent-trans', encrypt_oper, encrypt_rid), to=self._state.parent)
            self.send(('initial_transmission', encrypt_oper, encrypt_rid), to=self._state.rep[0])
            prec = self._state.rec
            super()._label('_st_label_483', block=False)
            _st_label_483 = 0
            self._timer_start()
            while (_st_label_483 == 0):
                _st_label_483 += 1
                if (self._state.rec == (prec + 1)):
                    logging.info(((((('Client ' + str(self._state.c.index(self._state.cid))) + ': Client ') + str(self._state.c.index(self._state.cid))) + ' result arrived before time - out for rid ') + str(self._state.rid)))
                    _st_label_483 += 1
                elif self._timer_expired:
                    logging.info(((((((('Client ' + str(self._state.c.index(self._state.cid))) + ': Client ') + str(self._state.c.index(self._state.cid))) + ' timer expired for  request number ') + str(self._state.rid)) + ' opration ') + self._state.x[i]))
                    self._state.timer_expired = True
                    for repl in self._state.rep:
                        time.sleep(0.01)
                        self.send(('re-trans-client', encrypt_oper, encrypt_rid), to=repl)
                    self._state.timer_expired = False
                    logging.info((((((((('Client ' + str(self._state.c.index(self._state.cid))) + ':  Client ') + str(self._state.c.index(self._state.cid))) + ' sent  request number ') + str(self._state.rid)) + ' operation ') + self._state.x[i]) + ' to all replicas after timeout'))
                    _st_label_483 += 1
                else:
                    super()._label('_st_label_483', block=True, timeout=self._state.client_timeout)
                    _st_label_483 -= 1
            else:
                if (_st_label_483 != 2):
                    continue
            if (_st_label_483 != 2):
                break
        super()._label('_st_label_609', block=False)
        _st_label_609 = 0
        while (_st_label_609 == 0):
            _st_label_609 += 1
            if (self._state.rec == len(self._state.x)):
                _st_label_609 += 1
            else:
                super()._label('_st_label_609', block=True)
                _st_label_609 -= 1
        self.send(('finish', self._state.result), to=self._state.parent)
        logging.info((((('Client ' + str(self._state.c.index(self._state.cid))) + ':  Client ') + str(self._state.c.index(self._state.cid))) + ' sent fianl results to parent for checking'))
        super()._label('_st_label_644', block=False)
        _st_label_644 = 0
        while (_st_label_644 == 0):
            _st_label_644 += 1
            if False:
                _st_label_644 += 1
            else:
                super()._label('_st_label_644', block=True)
                _st_label_644 -= 1

    def _CL_handler_648(self, encrypt_hashresult, encrypt_res, rid, replicas):
        match = 0
        for h in encrypt_hashresult:
            bres = nacl.encoding.HexEncoder.decode(h[1])
            orig_dgs = nacl.hash.sha256(bres, encoder=nacl.encoding.HexEncoder)
            if sodium_memcmp(h[0], orig_dgs):
                if (bres.decode() == encrypt_res):
                    match = (match + 1)
        if ((match >= self._state.min_match) and (self._state.rid_seen[rid] == 0)):
            self._state.rid_seen[rid] = 1
            match = 0
            logging.info(((((('Client ' + str(self._state.c.index(self._state.cid))) + ': Result validation success after receiving re-transmit result from replica ') + str(self._state.r.index(replicas))) + ' for rid ') + str(rid)))
            self._state.result.append(encrypt_res)
            self._state.rec = (self._state.rec + 1)
    _CL_handler_648._labels = None
    _CL_handler_648._notlabels = None

    def _CL_handler_769(self, encrypt_hashresult, encrypt_res, rid, tail):
        if (not self._state.timer_expired):
            c_t_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[tail], encoder=nacl.encoding.HexEncoder)
            try:
                c_t_dkey.verify(encrypt_hashresult)
                c_t_dkey.verify(encrypt_res)
                res = encrypt_res.message.decode()
                hashresult = eval(encrypt_hashresult.message.decode())
            except nacl.exceptions.BadSignatureError:
                logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ':  tail to client signature fail for rid +str(rid)'))
            logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ':  tail to client signature success for rid +str(rid)'))
            match = 0
            for h in hashresult:
                bres = nacl.encoding.HexEncoder.decode(h[1])
                orig_dgs = nacl.hash.sha256(bres, encoder=nacl.encoding.HexEncoder)
                if sodium_memcmp(h[0], orig_dgs):
                    if (bres.decode() == res):
                        match = (match + 1)
            if (match >= self._state.min_match):
                if (self._state.rid_seen[rid] == 0):
                    logging.info(((('Client ' + str(self._state.c.index(self._state.cid))) + ': Result validation success after receiving result from tail for rid ') + str(rid)))
                    self._state.result.append(res)
            else:
                logging.error(((('Client ' + str(self._state.c.index(self._state.cid))) + ': Result validation failed after receiving result from tail for rid ') + str(rid)))
                logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ': Reconfiguration request to Olympus'))
            self._state.rec = (self._state.rec + 1)
            match = 0
    _CL_handler_769._labels = None
    _CL_handler_769._notlabels = None
